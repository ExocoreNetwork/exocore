// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: exocore/assets/v1/genesis.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GenesisState defines the assets module's state. It needs to encompass
// all of the state that is required to start the chain from the genesis
// or in the event of a restart. At this point, it is only built with
// the former in mind.
// TODO: make this state exportable for the case of chain restarts.
type GenesisState struct {
	// params defines all the parameters of the module.
	Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
	// client_chains is the list of supported client chains,
	// that are supported at chain genesis (or restart).
	ClientChains []ClientChainInfo `protobuf:"bytes,2,rep,name=client_chains,json=clientChains,proto3" json:"client_chains"`
	// tokens is the list of supported client chain tokens and total staked amount
	// that are supported at chain genesis (or restart).
	Tokens []StakingAssetInfo `protobuf:"bytes,3,rep,name=tokens,proto3" json:"tokens"`
	// deposits is the list of deposits, indexed by staker address and
	// then the asset id. The struct is the `StakerAssetInfo`
	// which contains deposits, withdrawable and unbonding amount.
	// at genesis (not chain restart), the unbonding amount must be 0.
	Deposits []DepositsByStaker `protobuf:"bytes,4,rep,name=deposits,proto3" json:"deposits"`
	// operator_assets is the list of all operator assets information, indexed
	// by the operator address and the asset id. The struct is the `OperatorAssetInfo`
	OperatorAssets []AssetsByOperator `protobuf:"bytes,5,rep,name=operator_assets,json=operatorAssets,proto3" json:"operator_assets"`
	// not_init_from_boot_strap indicates whether the genesis state is initialized from
	// the bootStrap contract. If the flag is false, then the node starts from the
	// genesis.json generated by the bootStrap contract. This genesis.json might lack
	// some detailed state information, such as the `staking_total_amount` in the staking
	// assets info. When the flag is true, the node starts through the normal exported genesis
	// file. This flag is to address the compatibility between the two start methods.
	NotInitFromBootStrap bool `protobuf:"varint,6,opt,name=not_init_from_boot_strap,json=notInitFromBootStrap,proto3" json:"not_init_from_boot_strap,omitempty"`
}

func (m *GenesisState) Reset()         { *m = GenesisState{} }
func (m *GenesisState) String() string { return proto.CompactTextString(m) }
func (*GenesisState) ProtoMessage()    {}
func (*GenesisState) Descriptor() ([]byte, []int) {
	return fileDescriptor_caf4f124d39d82ce, []int{0}
}
func (m *GenesisState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisState.Merge(m, src)
}
func (m *GenesisState) XXX_Size() int {
	return m.Size()
}
func (m *GenesisState) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisState.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

func (m *GenesisState) GetClientChains() []ClientChainInfo {
	if m != nil {
		return m.ClientChains
	}
	return nil
}

func (m *GenesisState) GetTokens() []StakingAssetInfo {
	if m != nil {
		return m.Tokens
	}
	return nil
}

func (m *GenesisState) GetDeposits() []DepositsByStaker {
	if m != nil {
		return m.Deposits
	}
	return nil
}

func (m *GenesisState) GetOperatorAssets() []AssetsByOperator {
	if m != nil {
		return m.OperatorAssets
	}
	return nil
}

func (m *GenesisState) GetNotInitFromBootStrap() bool {
	if m != nil {
		return m.NotInitFromBootStrap
	}
	return false
}

// AssetsByOperator is a struct to be used in the genesis state.
// It is used to store the operator and its assets state.
type AssetsByOperator struct {
	// operator is the address of the operator,its type should be a sdk.AccAddress
	Operator string `protobuf:"bytes,1,opt,name=operator,proto3" json:"operator,omitempty"`
	// assets_state is the list of assets state, indexed by the asset id.
	// The struct is the `OperatorAssetInfo`
	AssetsState []AssetByID `protobuf:"bytes,2,rep,name=assets_state,json=assetsState,proto3" json:"assets_state"`
}

func (m *AssetsByOperator) Reset()         { *m = AssetsByOperator{} }
func (m *AssetsByOperator) String() string { return proto.CompactTextString(m) }
func (*AssetsByOperator) ProtoMessage()    {}
func (*AssetsByOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_caf4f124d39d82ce, []int{1}
}
func (m *AssetsByOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssetsByOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssetsByOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssetsByOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssetsByOperator.Merge(m, src)
}
func (m *AssetsByOperator) XXX_Size() int {
	return m.Size()
}
func (m *AssetsByOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_AssetsByOperator.DiscardUnknown(m)
}

var xxx_messageInfo_AssetsByOperator proto.InternalMessageInfo

func (m *AssetsByOperator) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *AssetsByOperator) GetAssetsState() []AssetByID {
	if m != nil {
		return m.AssetsState
	}
	return nil
}

// AssetByID is a helper struct to be used in the genesis state.
// It is used to store the asset id and its info for an operator.
// It is named AssetByID (since it is indexed by the assetID)
type AssetByID struct {
	// asset_id is the id of the asset.
	AssetID string `protobuf:"bytes,1,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// info is the asset info.
	Info OperatorAssetInfo `protobuf:"bytes,2,opt,name=info,proto3" json:"info"`
}

func (m *AssetByID) Reset()         { *m = AssetByID{} }
func (m *AssetByID) String() string { return proto.CompactTextString(m) }
func (*AssetByID) ProtoMessage()    {}
func (*AssetByID) Descriptor() ([]byte, []int) {
	return fileDescriptor_caf4f124d39d82ce, []int{2}
}
func (m *AssetByID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssetByID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssetByID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssetByID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssetByID.Merge(m, src)
}
func (m *AssetByID) XXX_Size() int {
	return m.Size()
}
func (m *AssetByID) XXX_DiscardUnknown() {
	xxx_messageInfo_AssetByID.DiscardUnknown(m)
}

var xxx_messageInfo_AssetByID proto.InternalMessageInfo

func (m *AssetByID) GetAssetID() string {
	if m != nil {
		return m.AssetID
	}
	return ""
}

func (m *AssetByID) GetInfo() OperatorAssetInfo {
	if m != nil {
		return m.Info
	}
	return OperatorAssetInfo{}
}

// DepositByStaker is a helper struct to be used in the genesis state.
// It is used to store the staker address and its deposits for each asset ID.
type DepositsByStaker struct {
	// staker is the address of the staker.
	StakerID string `protobuf:"bytes,1,opt,name=staker,proto3" json:"staker,omitempty"`
	// deposits is the list of deposits, indexed by the asset id.
	// The struct is the `StakerAssetInfo` which contains deposits,
	// withdrawable and unbonding amount.
	Deposits []DepositByAsset `protobuf:"bytes,2,rep,name=deposits,proto3" json:"deposits"`
}

func (m *DepositsByStaker) Reset()         { *m = DepositsByStaker{} }
func (m *DepositsByStaker) String() string { return proto.CompactTextString(m) }
func (*DepositsByStaker) ProtoMessage()    {}
func (*DepositsByStaker) Descriptor() ([]byte, []int) {
	return fileDescriptor_caf4f124d39d82ce, []int{3}
}
func (m *DepositsByStaker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositsByStaker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositsByStaker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositsByStaker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositsByStaker.Merge(m, src)
}
func (m *DepositsByStaker) XXX_Size() int {
	return m.Size()
}
func (m *DepositsByStaker) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositsByStaker.DiscardUnknown(m)
}

var xxx_messageInfo_DepositsByStaker proto.InternalMessageInfo

func (m *DepositsByStaker) GetStakerID() string {
	if m != nil {
		return m.StakerID
	}
	return ""
}

func (m *DepositsByStaker) GetDeposits() []DepositByAsset {
	if m != nil {
		return m.Deposits
	}
	return nil
}

// DepositByAsset is a helper struct to be used in the genesis state.
// It is used to store the asset id and its info for an staker.
// The info contains the deposit amount, the withdrawable amount
// and the amount currently unbonding.
// It is named DepositByAsset (since it is indexed by the assetID)
// and not Deposit to prevent conflict with CrossChainOpType.
type DepositByAsset struct {
	// asset_id is the id of the asset.
	AssetID string `protobuf:"bytes,1,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// info is the asset info.
	Info StakerAssetInfo `protobuf:"bytes,2,opt,name=info,proto3" json:"info"`
}

func (m *DepositByAsset) Reset()         { *m = DepositByAsset{} }
func (m *DepositByAsset) String() string { return proto.CompactTextString(m) }
func (*DepositByAsset) ProtoMessage()    {}
func (*DepositByAsset) Descriptor() ([]byte, []int) {
	return fileDescriptor_caf4f124d39d82ce, []int{4}
}
func (m *DepositByAsset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositByAsset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositByAsset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositByAsset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositByAsset.Merge(m, src)
}
func (m *DepositByAsset) XXX_Size() int {
	return m.Size()
}
func (m *DepositByAsset) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositByAsset.DiscardUnknown(m)
}

var xxx_messageInfo_DepositByAsset proto.InternalMessageInfo

func (m *DepositByAsset) GetAssetID() string {
	if m != nil {
		return m.AssetID
	}
	return ""
}

func (m *DepositByAsset) GetInfo() StakerAssetInfo {
	if m != nil {
		return m.Info
	}
	return StakerAssetInfo{}
}

func init() {
	proto.RegisterType((*GenesisState)(nil), "exocore.assets.v1.GenesisState")
	proto.RegisterType((*AssetsByOperator)(nil), "exocore.assets.v1.AssetsByOperator")
	proto.RegisterType((*AssetByID)(nil), "exocore.assets.v1.AssetByID")
	proto.RegisterType((*DepositsByStaker)(nil), "exocore.assets.v1.DepositsByStaker")
	proto.RegisterType((*DepositByAsset)(nil), "exocore.assets.v1.DepositByAsset")
}

func init() { proto.RegisterFile("exocore/assets/v1/genesis.proto", fileDescriptor_caf4f124d39d82ce) }

var fileDescriptor_caf4f124d39d82ce = []byte{
	// 573 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x94, 0xcf, 0x6e, 0xd3, 0x4c,
	0x14, 0xc5, 0xe3, 0xb6, 0x5f, 0x9a, 0x4e, 0xf2, 0x95, 0x32, 0xea, 0xc2, 0xad, 0x90, 0x53, 0x4c,
	0x85, 0xba, 0xc1, 0xa6, 0x05, 0xc1, 0x06, 0x21, 0xd5, 0x4d, 0x40, 0x41, 0x82, 0x22, 0x67, 0xc7,
	0xc6, 0x72, 0x9c, 0x89, 0x3b, 0x0a, 0x99, 0x6b, 0xcd, 0x0c, 0x21, 0x59, 0xf0, 0x0c, 0xf0, 0x20,
	0x2c, 0x79, 0x88, 0x2e, 0x2b, 0x56, 0xac, 0x22, 0x94, 0xbc, 0x08, 0xf2, 0xcc, 0x24, 0xa4, 0xf9,
	0x23, 0xb1, 0x73, 0xe6, 0x9c, 0xfb, 0x9b, 0x7b, 0x73, 0x8f, 0x8d, 0xaa, 0x64, 0x00, 0x09, 0x70,
	0xe2, 0xc7, 0x42, 0x10, 0x29, 0xfc, 0xfe, 0xa9, 0x9f, 0x12, 0x46, 0x04, 0x15, 0x5e, 0xc6, 0x41,
	0x02, 0xbe, 0x6b, 0x0c, 0x9e, 0x36, 0x78, 0xfd, 0xd3, 0xc3, 0x83, 0x04, 0x44, 0x0f, 0x44, 0xa4,
	0x0c, 0xbe, 0xfe, 0xa1, 0xdd, 0x87, 0xce, 0x32, 0x2e, 0x8b, 0x79, 0xdc, 0x9b, 0xea, 0x87, 0xcb,
	0xba, 0x1c, 0x18, 0x6d, 0x3f, 0x85, 0x14, 0x34, 0x33, 0x7f, 0xd2, 0xa7, 0xee, 0xf7, 0x4d, 0x54,
	0x79, 0xad, 0x3b, 0x6a, 0xca, 0x58, 0x12, 0xfc, 0x1c, 0x15, 0x35, 0xd2, 0xb6, 0x8e, 0xac, 0x93,
	0xf2, 0xd9, 0x81, 0xb7, 0xd4, 0xa1, 0xf7, 0x5e, 0x19, 0x82, 0xad, 0xeb, 0x51, 0xb5, 0x10, 0x1a,
	0x3b, 0x7e, 0x8b, 0xfe, 0x4f, 0x3e, 0x52, 0xc2, 0x64, 0x94, 0x5c, 0xc5, 0x94, 0x09, 0x7b, 0xe3,
	0x68, 0xf3, 0xa4, 0x7c, 0xe6, 0xae, 0xa8, 0xbf, 0x50, 0xbe, 0x8b, 0xdc, 0xd6, 0x60, 0x1d, 0x30,
	0xa0, 0x4a, 0xf2, 0xf7, 0x58, 0xe0, 0x73, 0x54, 0x94, 0xd0, 0x25, 0x4c, 0xd8, 0x9b, 0x8a, 0xf3,
	0x60, 0x05, 0xa7, 0x29, 0xe3, 0x2e, 0x65, 0xe9, 0x79, 0x7e, 0x30, 0x07, 0x32, 0x85, 0xb8, 0x8e,
	0x4a, 0x6d, 0x92, 0x81, 0xa0, 0x52, 0xd8, 0x5b, 0x6b, 0x21, 0x35, 0x63, 0x09, 0x86, 0x39, 0x8e,
	0x70, 0x03, 0x99, 0x95, 0xe2, 0x10, 0xdd, 0x81, 0x8c, 0xf0, 0x58, 0x02, 0x8f, 0x74, 0x99, 0xfd,
	0xdf, 0x5a, 0x9a, 0xea, 0x45, 0x04, 0xc3, 0x4b, 0x53, 0x61, 0x68, 0xbb, 0x53, 0x82, 0xd6, 0xf1,
	0x33, 0x64, 0x33, 0x90, 0x11, 0x65, 0x54, 0x46, 0x1d, 0x0e, 0xbd, 0xa8, 0x05, 0x20, 0x23, 0x21,
	0x79, 0x9c, 0xd9, 0xc5, 0x23, 0xeb, 0xa4, 0x14, 0xee, 0x33, 0x90, 0x0d, 0x46, 0xe5, 0x2b, 0x0e,
	0xbd, 0x00, 0x40, 0x36, 0x73, 0xcd, 0xfd, 0x6a, 0xa1, 0xbd, 0xc5, 0x2b, 0xf0, 0x53, 0x54, 0x9a,
	0xe2, 0xd5, 0xd2, 0x76, 0x02, 0xfb, 0xe7, 0x8f, 0x47, 0xfb, 0x26, 0x39, 0xe7, 0xed, 0x36, 0x27,
	0x42, 0x34, 0x25, 0xa7, 0x2c, 0x0d, 0x67, 0x4e, 0x5c, 0x47, 0x15, 0xdd, 0x76, 0x24, 0xf2, 0xc5,
	0x9b, 0x75, 0xdd, 0x5b, 0x37, 0x53, 0x30, 0x6c, 0xd4, 0xcc, 0x30, 0x65, 0x2d, 0xa9, 0xbc, 0xb8,
	0x02, 0xed, 0xcc, 0x74, 0xfc, 0x10, 0x95, 0x94, 0x16, 0xd1, 0xb6, 0xe9, 0xa4, 0x3c, 0x1e, 0x55,
	0xb7, 0xf5, 0x82, 0x6a, 0xe1, 0xb6, 0x12, 0x1b, 0x6d, 0xfc, 0x12, 0x6d, 0x51, 0xd6, 0x01, 0x7b,
	0x43, 0x45, 0xec, 0x78, 0xc5, 0x9d, 0x97, 0xf3, 0xff, 0xd7, 0xdc, 0x6e, 0x55, 0x9d, 0xfb, 0x05,
	0xed, 0x2d, 0xae, 0x0d, 0x1f, 0xa3, 0xa2, 0x50, 0x4f, 0xe6, 0xe6, 0xca, 0x78, 0x54, 0x2d, 0x69,
	0xad, 0x51, 0x0b, 0x8d, 0x86, 0x2f, 0xe6, 0x32, 0xa1, 0x27, 0xbe, 0xbf, 0x3e, 0x13, 0xc1, 0x50,
	0x8f, 0xb6, 0x90, 0x08, 0xb7, 0x8f, 0x76, 0x6f, 0x3b, 0xfe, 0x79, 0xf0, 0x17, 0xb7, 0x06, 0x77,
	0xd7, 0x64, 0x9a, 0xac, 0x1e, 0x3b, 0x78, 0x73, 0x3d, 0x76, 0xac, 0x9b, 0xb1, 0x63, 0xfd, 0x1e,
	0x3b, 0xd6, 0xb7, 0x89, 0x53, 0xb8, 0x99, 0x38, 0x85, 0x5f, 0x13, 0xa7, 0xf0, 0xe1, 0x71, 0x4a,
	0xe5, 0xd5, 0xa7, 0x96, 0x97, 0x40, 0xcf, 0xaf, 0x6b, 0xe6, 0x3b, 0x22, 0x3f, 0x03, 0xef, 0xfa,
	0xd3, 0x4f, 0xc2, 0x60, 0xfa, 0x51, 0x90, 0xc3, 0x8c, 0x88, 0x56, 0x51, 0xbd, 0xff, 0x4f, 0xfe,
	0x04, 0x00, 0x00, 0xff, 0xff, 0xff, 0x0b, 0x64, 0x2d, 0xa2, 0x04, 0x00, 0x00,
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NotInitFromBootStrap {
		i--
		if m.NotInitFromBootStrap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.OperatorAssets) > 0 {
		for iNdEx := len(m.OperatorAssets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OperatorAssets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Deposits) > 0 {
		for iNdEx := len(m.Deposits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Deposits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Tokens) > 0 {
		for iNdEx := len(m.Tokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ClientChains) > 0 {
		for iNdEx := len(m.ClientChains) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ClientChains[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AssetsByOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetsByOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssetsByOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetsState) > 0 {
		for iNdEx := len(m.AssetsState) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AssetsState[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AssetByID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetByID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssetByID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.AssetID) > 0 {
		i -= len(m.AssetID)
		copy(dAtA[i:], m.AssetID)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.AssetID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DepositsByStaker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositsByStaker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositsByStaker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Deposits) > 0 {
		for iNdEx := len(m.Deposits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Deposits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.StakerID) > 0 {
		i -= len(m.StakerID)
		copy(dAtA[i:], m.StakerID)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.StakerID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DepositByAsset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositByAsset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositByAsset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.AssetID) > 0 {
		i -= len(m.AssetID)
		copy(dAtA[i:], m.AssetID)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.AssetID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintGenesis(dAtA []byte, offset int, v uint64) int {
	offset -= sovGenesis(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GenesisState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovGenesis(uint64(l))
	if len(m.ClientChains) > 0 {
		for _, e := range m.ClientChains {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.Tokens) > 0 {
		for _, e := range m.Tokens {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.Deposits) > 0 {
		for _, e := range m.Deposits {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.OperatorAssets) > 0 {
		for _, e := range m.OperatorAssets {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if m.NotInitFromBootStrap {
		n += 2
	}
	return n
}

func (m *AssetsByOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	if len(m.AssetsState) > 0 {
		for _, e := range m.AssetsState {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	return n
}

func (m *AssetByID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AssetID)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = m.Info.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *DepositsByStaker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StakerID)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	if len(m.Deposits) > 0 {
		for _, e := range m.Deposits {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	return n
}

func (m *DepositByAsset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AssetID)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = m.Info.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func sovGenesis(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGenesis(x uint64) (n int) {
	return sovGenesis(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GenesisState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientChains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientChains = append(m.ClientChains, ClientChainInfo{})
			if err := m.ClientChains[len(m.ClientChains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokens = append(m.Tokens, StakingAssetInfo{})
			if err := m.Tokens[len(m.Tokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposits = append(m.Deposits, DepositsByStaker{})
			if err := m.Deposits[len(m.Deposits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorAssets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorAssets = append(m.OperatorAssets, AssetsByOperator{})
			if err := m.OperatorAssets[len(m.OperatorAssets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotInitFromBootStrap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotInitFromBootStrap = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetsByOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetsByOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetsByOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetsState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetsState = append(m.AssetsState, AssetByID{})
			if err := m.AssetsState[len(m.AssetsState)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetByID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetByID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetByID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositsByStaker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositsByStaker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositsByStaker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposits = append(m.Deposits, DepositByAsset{})
			if err := m.Deposits[len(m.Deposits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositByAsset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositByAsset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositByAsset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGenesis(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGenesis
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGenesis
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGenesis
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGenesis        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGenesis          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGenesis = fmt.Errorf("proto: unexpected end of group")
)
