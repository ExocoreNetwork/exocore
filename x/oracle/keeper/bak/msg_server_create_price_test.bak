func TestCreatePrice(t *testing.T) {
	ms, ctx, k := setupMsgServer(t)
	require.NotNil(t, ms)
	require.NotNil(t, ctx)

	ctrl := gomock.NewController(t)
	validatorC := NewMockValidatorI(ctrl)
	validatorC.EXPECT().GetBondedTokens().Return(math.NewInt(1))
	validatorC.EXPECT().GetBondedTokens().Return(math.NewInt(1))
	validatorC.EXPECT().GetBondedTokens().Return(math.NewInt(1))

	validatorC.EXPECT().GetConsensusPower(gomock.Any()).Return(int64(1))
	validatorC.EXPECT().GetConsensusPower(gomock.Any()).Return(int64(1))
	validatorC.EXPECT().GetConsensusPower(gomock.Any()).Return(int64(1))

	privVal1 := mock.NewPV()
	pubKey1, _ := privVal1.GetPubKey()
	operator1 := sdk.ValAddress(pubKey1.Address())

	privVal2 := mock.NewPV()
	pubKey2, _ := privVal2.GetPubKey()
	operator2 := sdk.ValAddress(pubKey2.Address())

	privVal3 := mock.NewPV()
	pubKey3, _ := privVal3.GetPubKey()
	operator3 := sdk.ValAddress(pubKey3.Address())

	validatorC.EXPECT().GetOperator().Return(operator1)
	validatorC.EXPECT().GetOperator().Return(operator2)
	validatorC.EXPECT().GetOperator().Return(operator3)

	monkey.PatchInstanceMethod(reflect.TypeOf(keeper.Keeper{}), "IterateBondedValidatorsByPower", func(k keeper.Keeper, ctx sdk.Context, f func(index int64, validator stakingtypes.ValidatorI) bool) {
		f(0, validatorC)
		f(0, validatorC)
		f(0, validatorC)
	})
	monkey.PatchInstanceMethod(reflect.TypeOf(keeper.Keeper{}), "GetLastTotalPower", func(k keeper.Keeper, ctx sdk.Context) *big.Int { return big.NewInt(3) })
	wCtx := sdk.UnwrapSDKContext(ctx)
	h := wCtx.BlockHeight()
	assert.Equal(t, int64(2), h)
	vpRes := make(map[string]*big.Int)
	c := keeper.GetCaches()
	c.GetCache(cache.CacheItemV(vpRes))
	//	fmt.Println("Caches get validatorPowers", vpRes)
	ms.CreatePrice(ctx, &types.MsgCreatePrice{
		Creator:  operator1.String(),
		FeederId: 1,
		Prices: []*types.PriceWithSource{
			{
				SourceId: 1,
				Prices: []*types.PriceWithTimeAndDetId{
					{
						Price:     "1000",
						Decimal:   1,
						Timestamp: "",
						DetId:     "5",
					},
				},
				Desc: "",
			},
		},
		BasedBlock: 1,
		Nonce:      1,
	},
	)

	pRes := &common.Params{}
	c.GetCache(cache.CacheItemP(pRes))
	//	fmt.Println("Caches get params", pRes)

	iRes := make([]*cache.CacheItemM, 0)
	c.GetCache(&iRes)
	//fmt.Println("Caches get itemM", len(iRes), iRes[0])

	ms.CreatePrice(ctx, &types.MsgCreatePrice{
		Creator:  operator2.String(),
		FeederId: 1,
		Prices: []*types.PriceWithSource{
			{
				SourceId: 1,
				Prices: []*types.PriceWithTimeAndDetId{
					{
						Price:     "1090",
						Decimal:   1,
						Timestamp: "",
						DetId:     "6",
					},
					{
						Price:     "1000",
						Decimal:   1,
						Timestamp: "",
						DetId:     "5",
					},
				},
				Desc: "",
			},
		},
		BasedBlock: 1,
		Nonce:      1,
	},
	)
	ms.CreatePrice(ctx, &types.MsgCreatePrice{})
	c.GetCache(&iRes)
	//fmt.Println("Caches get itemM", len(iRes), iRes[0], iRes[1])
	ms.CreatePrice(ctx, &types.MsgCreatePrice{
		Creator:  operator3.String(),
		FeederId: 1,
		Prices: []*types.PriceWithSource{
			{
				SourceId: 1,
				Prices: []*types.PriceWithTimeAndDetId{
					{
						Price:     "1000",
						Decimal:   1,
						Timestamp: "",
						DetId:     "5",
					},
				},
				Desc: "",
			},
		},
		BasedBlock: 1,
		Nonce:      1,
	},
	)

	c.GetCache(&iRes)
	//fmt.Println("Caches get itemM", len(iRes))
	fmt.Println(k.GetAllPrices(sdk.UnwrapSDKContext(ctx)))

}
