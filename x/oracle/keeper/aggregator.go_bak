package keeper

import (
	"github.com/ExocoreNetwork/exocore/x/oracle/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
)

type filter struct {
}

type calculator struct {
}

type aggregator struct {
}

var agg *aggregator

// TODO: we do the translation here from KVstore's tokenId->data in both roundInfo and roundData for calculation convinence, but this cause additional calculation
// TODO: !!!neeed to refactor the key for KVStore for both these two stucture before deployed
type aggregator struct {
	//read only, params will not be modified from aggregagor
	params *params
	//context infomation for every round aggregation corespond to each tokenId
	roundInfo map[int32]*types.RoundInfo
	//collec
	roundData map[int32]*types.RoundData
	//	validators map[uint64]*types.Validators
	validators []*types.Validators

	k Keeper
}

func GetAggregator() *aggregator {
	if agg != nil {
		return agg
	}
	return &aggregator{}
}

func (k *Keeper) RecacheAgg(ctx sdk.Context) {

}

// UpdateParams will update the params in mem cache, check and conduce all related consequece from this update.
func (k *Keeper) UpdateParams4Agg(ctx sdk.Context) {

	//triggered by k.SetParams and do the validation and update on agg context{roundInfo, roundData, }
	// agg.params = k.GetParams(ctx)
	if agg.params == nil {
		//prepare the initial params, just set the value, with the server on, this will be called once, and updated everytime the params be updated.
		//this must be the very first time we interact with the aggregator, so recache any possible contextInfo(roundInfo, roundData) from KVStore(eg. restart a node)
		return
	}
	//udpate params with specified keys, and trigger the ralted modificaiton for the context(roundId, roundData)

}

// UpdateContext4Agg updates related data in roundInfo and this may trigger modification on roundData
func (k *Keeper) UpdateContext4Agg(ctx sdk.Context) {
	//fill roundInfo for all aflice feeders, do this in The EndBlock, prepare all context for the next block
	//check/update agg.params first
	//iterates feeders to fill roundInfo
	//ops: 1. status:1, 2
	//ops: 2. trigger AppendPrices(success, failed, both lead to a new roundId)
}

//func (k *Keeper) PrepareRoundInfo(ctx sdk.Context) {
//
//}

// When the aggregation completed(both success and fail), this method will be called to set the Price of a now round and increase the corresponding NextRoundId
func (k *Keeper) AppendPricesAndSeal(ctx sdk.Context, tokenId int32, roundId uint64, price types.PriceWithTimeAndRound) {
	//When aggregation is completed(both success or fail), prices will be updated with new roundId
}

func (k *Keeper) GetFeederIdStatus(feederId int32) bool {
	//	if feeder := k.params.getTokenFeeder(feederId); feeder != nil{
	//		agg.RoundInfo[]
	//		return  TODO
	//	}
	return agg.roundInfo[feederId].Status == int32(1)
}

func (k *Keeper) UpdatePrices() {

}
