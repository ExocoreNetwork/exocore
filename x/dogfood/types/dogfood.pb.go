// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: exocore/dogfood/v1/dogfood.proto

package types

import (
	fmt "fmt"
	crypto "github.com/cometbft/cometbft/proto/tendermint/crypto"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// OperationType is used to indicate the type of operation that is being
// cached by the module to create the updated validator set.
type OperationType int32

const (
	// KeyOpUnspecified is used to indicate that the operation type is not specified.
	// This should never be used.
	KeyOpUnspecified OperationType = 0
	// KeyAddition is used to indicate that the operation is a key addition.
	KeyAdditionOrUpdate OperationType = 1
	// KeyRemoval is used to indicate that the operation is a key removal. Typically
	// this is done due to key replacement mechanism and not directly.
	KeyRemoval OperationType = 2
)

var OperationType_name = map[int32]string{
	0: "OPERATION_TYPE_UNSPECIFIED",
	1: "OPERATION_TYPE_ADDITION_OR_UPDATE",
	2: "OPERATION_TYPE_REMOVAL",
}

var OperationType_value = map[string]int32{
	"OPERATION_TYPE_UNSPECIFIED":        0,
	"OPERATION_TYPE_ADDITION_OR_UPDATE": 1,
	"OPERATION_TYPE_REMOVAL":            2,
}

func (x OperationType) String() string {
	return proto.EnumName(OperationType_name, int32(x))
}

func (OperationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_071b9989c501c3f2, []int{0}
}

// QueueResultType is used to indicate the result of the queue operation.
type QueueResultType int32

const (
	// QueueResultUnspecified is used to indicate that the queue result type is not specified.
	QueueResultUnspecified QueueResultType = 0
	// QueueResultSuccess is used to indicate that the queue operation was successful.
	QueueResultSuccess QueueResultType = 1
	// QueueResultExists is used to indicate that the queue operation failed because the
	// operation already exists in the queue.
	QueueResultExists QueueResultType = 2
	// QueueResultRemoved is used to indicate that the queue operation resulted in an existing
	// operation being removed from the queue.
	QueueResultRemoved QueueResultType = 3
)

var QueueResultType_name = map[int32]string{
	0: "QUEUE_RESULT_TYPE_UNSPECIFIED",
	1: "QUEUE_RESULT_TYPE_SUCCESS",
	2: "QUEUE_RESULT_TYPE_EXISTS",
	3: "QUEUE_RESULT_TYPE_REMOVED",
}

var QueueResultType_value = map[string]int32{
	"QUEUE_RESULT_TYPE_UNSPECIFIED": 0,
	"QUEUE_RESULT_TYPE_SUCCESS":     1,
	"QUEUE_RESULT_TYPE_EXISTS":      2,
	"QUEUE_RESULT_TYPE_REMOVED":     3,
}

func (x QueueResultType) String() string {
	return proto.EnumName(QueueResultType_name, int32(x))
}

func (QueueResultType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_071b9989c501c3f2, []int{1}
}

// ExocoreValidator is a validator that is part of the Exocore network. It is
// used to validate and sign blocks and transactions.
type ExocoreValidator struct {
	// The address, as derived from the consensus key. It has no relation
	// with the operator's account address.
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Last known power
	Power int64 `protobuf:"varint,2,opt,name=power,proto3" json:"power,omitempty"`
	// pubkey is the consensus public key of the validator, as a Protobuf Any.
	Pubkey *types.Any `protobuf:"bytes,3,opt,name=pubkey,proto3" json:"pubkey,omitempty" yaml:"consensus_pubkey"`
}

func (m *ExocoreValidator) Reset()         { *m = ExocoreValidator{} }
func (m *ExocoreValidator) String() string { return proto.CompactTextString(m) }
func (*ExocoreValidator) ProtoMessage()    {}
func (*ExocoreValidator) Descriptor() ([]byte, []int) {
	return fileDescriptor_071b9989c501c3f2, []int{0}
}
func (m *ExocoreValidator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExocoreValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExocoreValidator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExocoreValidator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExocoreValidator.Merge(m, src)
}
func (m *ExocoreValidator) XXX_Size() int {
	return m.Size()
}
func (m *ExocoreValidator) XXX_DiscardUnknown() {
	xxx_messageInfo_ExocoreValidator.DiscardUnknown(m)
}

var xxx_messageInfo_ExocoreValidator proto.InternalMessageInfo

func (m *ExocoreValidator) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *ExocoreValidator) GetPower() int64 {
	if m != nil {
		return m.Power
	}
	return 0
}

func (m *ExocoreValidator) GetPubkey() *types.Any {
	if m != nil {
		return m.Pubkey
	}
	return nil
}

// Operation is used to indicate the operation that is being cached by the module
// to create the updated validator set.
type Operation struct {
	// OperationType is the type of the operation (addition / removal).
	OperationType OperationType `protobuf:"varint,1,opt,name=operation_type,json=operationType,proto3,enum=exocore.dogfood.v1.OperationType" json:"operation_type,omitempty"`
	// OperatorAddress is the sdk.AccAddress of the operator.
	OperatorAddress []byte `protobuf:"bytes,2,opt,name=operator_address,json=operatorAddress,proto3" json:"operator_address,omitempty"`
	// PubKey is the public key for which the operation is being applied.
	PubKey crypto.PublicKey `protobuf:"bytes,3,opt,name=pub_key,json=pubKey,proto3" json:"pub_key"`
}

func (m *Operation) Reset()         { *m = Operation{} }
func (m *Operation) String() string { return proto.CompactTextString(m) }
func (*Operation) ProtoMessage()    {}
func (*Operation) Descriptor() ([]byte, []int) {
	return fileDescriptor_071b9989c501c3f2, []int{1}
}
func (m *Operation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Operation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Operation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Operation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Operation.Merge(m, src)
}
func (m *Operation) XXX_Size() int {
	return m.Size()
}
func (m *Operation) XXX_DiscardUnknown() {
	xxx_messageInfo_Operation.DiscardUnknown(m)
}

var xxx_messageInfo_Operation proto.InternalMessageInfo

func (m *Operation) GetOperationType() OperationType {
	if m != nil {
		return m.OperationType
	}
	return KeyOpUnspecified
}

func (m *Operation) GetOperatorAddress() []byte {
	if m != nil {
		return m.OperatorAddress
	}
	return nil
}

func (m *Operation) GetPubKey() crypto.PublicKey {
	if m != nil {
		return m.PubKey
	}
	return crypto.PublicKey{}
}

// Operations is a collection of Operation.
type Operations struct {
	List []Operation `protobuf:"bytes,1,rep,name=list,proto3" json:"list"`
}

func (m *Operations) Reset()         { *m = Operations{} }
func (m *Operations) String() string { return proto.CompactTextString(m) }
func (*Operations) ProtoMessage()    {}
func (*Operations) Descriptor() ([]byte, []int) {
	return fileDescriptor_071b9989c501c3f2, []int{2}
}
func (m *Operations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Operations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Operations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Operations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Operations.Merge(m, src)
}
func (m *Operations) XXX_Size() int {
	return m.Size()
}
func (m *Operations) XXX_DiscardUnknown() {
	xxx_messageInfo_Operations.DiscardUnknown(m)
}

var xxx_messageInfo_Operations proto.InternalMessageInfo

func (m *Operations) GetList() []Operation {
	if m != nil {
		return m.List
	}
	return nil
}

// AccountAddresses represents a list of account addresses. It is used to store the list of
// operator addresses whose operations are maturing at an epoch.
type AccountAddresses struct {
	List [][]byte `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
}

func (m *AccountAddresses) Reset()         { *m = AccountAddresses{} }
func (m *AccountAddresses) String() string { return proto.CompactTextString(m) }
func (*AccountAddresses) ProtoMessage()    {}
func (*AccountAddresses) Descriptor() ([]byte, []int) {
	return fileDescriptor_071b9989c501c3f2, []int{3}
}
func (m *AccountAddresses) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountAddresses) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountAddresses.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountAddresses) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountAddresses.Merge(m, src)
}
func (m *AccountAddresses) XXX_Size() int {
	return m.Size()
}
func (m *AccountAddresses) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountAddresses.DiscardUnknown(m)
}

var xxx_messageInfo_AccountAddresses proto.InternalMessageInfo

func (m *AccountAddresses) GetList() [][]byte {
	if m != nil {
		return m.List
	}
	return nil
}

// ConsensusAddresses represents a list of account addresses. It is used to store the list of
// addresses (which correspond to operator public keys) to delete at the end of an epoch.
type ConsensusAddresses struct {
	List [][]byte `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
}

func (m *ConsensusAddresses) Reset()         { *m = ConsensusAddresses{} }
func (m *ConsensusAddresses) String() string { return proto.CompactTextString(m) }
func (*ConsensusAddresses) ProtoMessage()    {}
func (*ConsensusAddresses) Descriptor() ([]byte, []int) {
	return fileDescriptor_071b9989c501c3f2, []int{4}
}
func (m *ConsensusAddresses) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusAddresses) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusAddresses.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusAddresses) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusAddresses.Merge(m, src)
}
func (m *ConsensusAddresses) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusAddresses) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusAddresses.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusAddresses proto.InternalMessageInfo

func (m *ConsensusAddresses) GetList() [][]byte {
	if m != nil {
		return m.List
	}
	return nil
}

func init() {
	proto.RegisterEnum("exocore.dogfood.v1.OperationType", OperationType_name, OperationType_value)
	proto.RegisterEnum("exocore.dogfood.v1.QueueResultType", QueueResultType_name, QueueResultType_value)
	proto.RegisterType((*ExocoreValidator)(nil), "exocore.dogfood.v1.ExocoreValidator")
	proto.RegisterType((*Operation)(nil), "exocore.dogfood.v1.Operation")
	proto.RegisterType((*Operations)(nil), "exocore.dogfood.v1.Operations")
	proto.RegisterType((*AccountAddresses)(nil), "exocore.dogfood.v1.AccountAddresses")
	proto.RegisterType((*ConsensusAddresses)(nil), "exocore.dogfood.v1.ConsensusAddresses")
}

func init() { proto.RegisterFile("exocore/dogfood/v1/dogfood.proto", fileDescriptor_071b9989c501c3f2) }

var fileDescriptor_071b9989c501c3f2 = []byte{
	// 705 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x94, 0xcf, 0x4e, 0xdb, 0x4a,
	0x14, 0xc6, 0xe3, 0x84, 0x0b, 0xba, 0xc3, 0x3f, 0xdf, 0xb9, 0x29, 0x04, 0x0b, 0x82, 0xc9, 0xa2,
	0x4a, 0x91, 0x6a, 0x0b, 0x68, 0x55, 0xa9, 0x55, 0x2b, 0x99, 0xc4, 0x55, 0xa3, 0x50, 0x12, 0xec,
	0x18, 0xb5, 0xdd, 0x58, 0x8e, 0x7d, 0x48, 0x2d, 0x12, 0x8f, 0xe5, 0xb1, 0x01, 0xbf, 0x41, 0x95,
	0x55, 0x5f, 0x20, 0xab, 0xaa, 0x6f, 0x50, 0xa9, 0xab, 0xee, 0x51, 0x57, 0x2c, 0xbb, 0x42, 0x15,
	0xbc, 0x41, 0x77, 0xdd, 0x55, 0xf1, 0x1f, 0x48, 0x09, 0x62, 0xe7, 0x6f, 0xce, 0xf9, 0x66, 0x7e,
	0xdf, 0x91, 0x67, 0x10, 0x0f, 0x27, 0xc4, 0x24, 0x1e, 0x88, 0x16, 0xe9, 0x1c, 0x10, 0x62, 0x89,
	0x47, 0x1b, 0xe9, 0xa7, 0xe0, 0x7a, 0xc4, 0x27, 0x18, 0x27, 0x1d, 0x42, 0xba, 0x7c, 0xb4, 0xc1,
	0xe5, 0x3b, 0xa4, 0x43, 0xa2, 0xb2, 0x38, 0xfc, 0x8a, 0x3b, 0xb9, 0xa5, 0x0e, 0x21, 0x9d, 0x2e,
	0x88, 0x91, 0x6a, 0x07, 0x07, 0xa2, 0xe1, 0x84, 0x69, 0xc9, 0x24, 0xb4, 0x47, 0xa8, 0x1e, 0x7b,
	0x62, 0x91, 0x94, 0x96, 0x7d, 0x70, 0x2c, 0xf0, 0x7a, 0xb6, 0xe3, 0x8b, 0xa6, 0x17, 0xba, 0x3e,
	0x11, 0x0f, 0x21, 0x4c, 0xaa, 0xa5, 0xcf, 0x0c, 0x62, 0xe5, 0x18, 0x60, 0xdf, 0xe8, 0xda, 0x96,
	0xe1, 0x13, 0x0f, 0x17, 0xd0, 0x94, 0x61, 0x59, 0x1e, 0x50, 0x5a, 0x60, 0x78, 0xa6, 0x3c, 0xa3,
	0xa4, 0x12, 0xe7, 0xd1, 0x3f, 0x2e, 0x39, 0x06, 0xaf, 0x90, 0xe5, 0x99, 0x72, 0x4e, 0x89, 0x05,
	0x36, 0xd0, 0xa4, 0x1b, 0xb4, 0x0f, 0x21, 0x2c, 0xe4, 0x78, 0xa6, 0x3c, 0xbd, 0x99, 0x17, 0x62,
	0x52, 0x21, 0x25, 0x15, 0x24, 0x27, 0xdc, 0xde, 0xfa, 0x75, 0xbe, 0xba, 0x18, 0x1a, 0xbd, 0xee,
	0xd3, 0x92, 0x49, 0x1c, 0x0a, 0x0e, 0x0d, 0xa8, 0x1e, 0xfb, 0x4a, 0xdf, 0xbf, 0x3c, 0xcc, 0x27,
	0xd4, 0x31, 0xa3, 0xd0, 0x0c, 0xda, 0x75, 0x08, 0x95, 0x64, 0xe3, 0xd2, 0x37, 0x06, 0xfd, 0xdb,
	0x70, 0xc1, 0x33, 0x7c, 0x9b, 0x38, 0xf8, 0x15, 0x9a, 0x23, 0xa9, 0xd0, 0xfd, 0xd0, 0x85, 0x88,
	0x73, 0x6e, 0x73, 0x4d, 0x18, 0x1f, 0xa6, 0x70, 0x65, 0x6b, 0x85, 0x2e, 0x28, 0xb3, 0x64, 0x54,
	0xe2, 0x07, 0x88, 0x8d, 0x17, 0x88, 0xa7, 0xa7, 0x99, 0xb3, 0x51, 0xe6, 0xf9, 0x74, 0x5d, 0x4a,
	0xb2, 0x3f, 0x43, 0x53, 0x6e, 0xd0, 0xd6, 0xaf, 0x63, 0x2e, 0x0b, 0xd7, 0xa3, 0x1d, 0xc1, 0xee,
	0xda, 0x66, 0x1d, 0xc2, 0xed, 0x89, 0xd3, 0xf3, 0xd5, 0x4c, 0xc4, 0x5f, 0x87, 0xb0, 0x24, 0x23,
	0x74, 0xc5, 0x41, 0xf1, 0x13, 0x34, 0xd1, 0xb5, 0xa9, 0x5f, 0x60, 0xf8, 0x5c, 0x79, 0x7a, 0x73,
	0xe5, 0x4e, 0xea, 0x64, 0xa3, 0xc8, 0x50, 0xba, 0x8f, 0x58, 0xc9, 0x34, 0x49, 0xe0, 0xf8, 0x09,
	0x15, 0x50, 0x8c, 0x47, 0x36, 0x9b, 0x49, 0xfa, 0xca, 0x08, 0x57, 0xd2, 0x19, 0xdf, 0xd9, 0xb9,
	0xfe, 0x95, 0x41, 0xb3, 0x7f, 0x4d, 0x08, 0x3f, 0x42, 0x5c, 0xa3, 0x29, 0x2b, 0x52, 0xab, 0xd6,
	0xd8, 0xd5, 0x5b, 0x6f, 0x9b, 0xb2, 0xae, 0xed, 0xaa, 0x4d, 0xb9, 0x52, 0x7b, 0x59, 0x93, 0xab,
	0x6c, 0x86, 0xcb, 0xf7, 0x07, 0x3c, 0x5b, 0x87, 0xb0, 0xe1, 0x6a, 0x0e, 0x75, 0xc1, 0xb4, 0x0f,
	0x6c, 0xb0, 0xf0, 0x0b, 0xb4, 0x76, 0xc3, 0x25, 0x55, 0xab, 0xb5, 0x48, 0x35, 0x14, 0x5d, 0x6b,
	0x56, 0xa5, 0x96, 0xcc, 0x32, 0xdc, 0x62, 0x7f, 0xc0, 0xff, 0x5f, 0x87, 0x50, 0xb2, 0x2c, 0x7b,
	0x78, 0x62, 0xc3, 0xd3, 0x5c, 0xcb, 0xf0, 0x01, 0xaf, 0xa3, 0x85, 0x1b, 0x7e, 0x45, 0x7e, 0xdd,
	0xd8, 0x97, 0x76, 0xd8, 0x2c, 0x37, 0xd7, 0x1f, 0xf0, 0x68, 0xf8, 0x37, 0x40, 0x8f, 0x1c, 0x19,
	0x5d, 0x6e, 0xe2, 0xc3, 0xa7, 0x62, 0x66, 0xfd, 0x37, 0x83, 0xe6, 0xf7, 0x02, 0x08, 0x40, 0x01,
	0x1a, 0x74, 0xfd, 0x88, 0xfd, 0x39, 0x5a, 0xd9, 0xd3, 0x64, 0x6d, 0x68, 0x56, 0xb5, 0x9d, 0xd6,
	0x6d, 0xf8, 0x5c, 0x7f, 0xc0, 0x2f, 0x8c, 0xf8, 0x46, 0x43, 0x3c, 0x46, 0x4b, 0xe3, 0x76, 0x55,
	0xab, 0x54, 0x64, 0x55, 0x65, 0x19, 0x6e, 0xa1, 0x3f, 0xe0, 0xf1, 0x88, 0x55, 0x0d, 0x4c, 0x73,
	0xf8, 0x67, 0x6c, 0xa1, 0xc2, 0xb8, 0x4d, 0x7e, 0x53, 0x53, 0x5b, 0x2a, 0x9b, 0xe5, 0xee, 0xf5,
	0x07, 0xfc, 0x7f, 0x23, 0x2e, 0xf9, 0xc4, 0xa6, 0x3e, 0xbd, 0xfd, 0xac, 0x28, 0xb3, 0x5c, 0x65,
	0x73, 0x63, 0x67, 0x45, 0xd9, 0xc1, 0x8a, 0xb3, 0x6f, 0xd7, 0x4f, 0x2f, 0x8a, 0xcc, 0xd9, 0x45,
	0x91, 0xf9, 0x79, 0x51, 0x64, 0x3e, 0x5e, 0x16, 0x33, 0x67, 0x97, 0xc5, 0xcc, 0x8f, 0xcb, 0x62,
	0xe6, 0xdd, 0x46, 0xc7, 0xf6, 0xdf, 0x07, 0x6d, 0xc1, 0x24, 0x3d, 0x31, 0xb9, 0xd8, 0xbb, 0xe0,
	0x1f, 0x13, 0xef, 0x50, 0x4c, 0x9f, 0xa2, 0x93, 0xab, 0xc7, 0x68, 0x78, 0x75, 0x68, 0x7b, 0x32,
	0xba, 0xa6, 0x5b, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xa3, 0xf3, 0x23, 0x11, 0xac, 0x04, 0x00,
	0x00,
}

func (m *ExocoreValidator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExocoreValidator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExocoreValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pubkey != nil {
		{
			size, err := m.Pubkey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDogfood(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Power != 0 {
		i = encodeVarintDogfood(dAtA, i, uint64(m.Power))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintDogfood(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Operation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Operation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Operation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PubKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintDogfood(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.OperatorAddress) > 0 {
		i -= len(m.OperatorAddress)
		copy(dAtA[i:], m.OperatorAddress)
		i = encodeVarintDogfood(dAtA, i, uint64(len(m.OperatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.OperationType != 0 {
		i = encodeVarintDogfood(dAtA, i, uint64(m.OperationType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Operations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Operations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Operations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDogfood(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AccountAddresses) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountAddresses) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountAddresses) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.List[iNdEx])
			copy(dAtA[i:], m.List[iNdEx])
			i = encodeVarintDogfood(dAtA, i, uint64(len(m.List[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusAddresses) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusAddresses) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusAddresses) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.List[iNdEx])
			copy(dAtA[i:], m.List[iNdEx])
			i = encodeVarintDogfood(dAtA, i, uint64(len(m.List[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintDogfood(dAtA []byte, offset int, v uint64) int {
	offset -= sovDogfood(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ExocoreValidator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovDogfood(uint64(l))
	}
	if m.Power != 0 {
		n += 1 + sovDogfood(uint64(m.Power))
	}
	if m.Pubkey != nil {
		l = m.Pubkey.Size()
		n += 1 + l + sovDogfood(uint64(l))
	}
	return n
}

func (m *Operation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OperationType != 0 {
		n += 1 + sovDogfood(uint64(m.OperationType))
	}
	l = len(m.OperatorAddress)
	if l > 0 {
		n += 1 + l + sovDogfood(uint64(l))
	}
	l = m.PubKey.Size()
	n += 1 + l + sovDogfood(uint64(l))
	return n
}

func (m *Operations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovDogfood(uint64(l))
		}
	}
	return n
}

func (m *AccountAddresses) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, b := range m.List {
			l = len(b)
			n += 1 + l + sovDogfood(uint64(l))
		}
	}
	return n
}

func (m *ConsensusAddresses) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, b := range m.List {
			l = len(b)
			n += 1 + l + sovDogfood(uint64(l))
		}
	}
	return n
}

func sovDogfood(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDogfood(x uint64) (n int) {
	return sovDogfood(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ExocoreValidator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDogfood
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExocoreValidator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExocoreValidator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDogfood
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDogfood
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDogfood
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDogfood
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pubkey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDogfood
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDogfood
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDogfood
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pubkey == nil {
				m.Pubkey = &types.Any{}
			}
			if err := m.Pubkey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDogfood(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDogfood
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Operation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDogfood
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Operation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Operation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationType", wireType)
			}
			m.OperationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDogfood
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperationType |= OperationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDogfood
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDogfood
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDogfood
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorAddress = append(m.OperatorAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.OperatorAddress == nil {
				m.OperatorAddress = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDogfood
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDogfood
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDogfood
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PubKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDogfood(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDogfood
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Operations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDogfood
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Operations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Operations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDogfood
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDogfood
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDogfood
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, Operation{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDogfood(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDogfood
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountAddresses) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDogfood
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountAddresses: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountAddresses: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDogfood
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDogfood
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDogfood
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, make([]byte, postIndex-iNdEx))
			copy(m.List[len(m.List)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDogfood(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDogfood
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusAddresses) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDogfood
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusAddresses: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusAddresses: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDogfood
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDogfood
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDogfood
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, make([]byte, postIndex-iNdEx))
			copy(m.List[len(m.List)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDogfood(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDogfood
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDogfood(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDogfood
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDogfood
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDogfood
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDogfood
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDogfood
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDogfood
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDogfood        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDogfood          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDogfood = fmt.Errorf("proto: unexpected end of group")
)
