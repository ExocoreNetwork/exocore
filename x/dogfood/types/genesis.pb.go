// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: exocore/dogfood/v1/genesis.proto

package types

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GenesisState defines the dogfood module's genesis state. Note that, as always,
// `genesis` is a misnomer. Ideally, this state can be exported at any point in
// time (or height), and reimported elsewhere where it will be the new genesis
// potentially at a non-zero height. In other words, it is the entire, current,
// state of the module.
type GenesisState struct {
	// params refers to the parameters of the module.
	Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
	// val_set is the initial validator set. it onyl represents the active
	// validators.
	ValSet []GenesisValidator `protobuf:"bytes,2,rep,name=val_set,json=valSet,proto3" json:"val_set"`
	// opt_out_expiries is a list of (future) epochs at the end of which the
	// corresponding operators' opt-out will expire. we store this, as well as its reverse
	// lookup.
	OptOutExpiries []EpochToOperatorAddrs `protobuf:"bytes,3,rep,name=opt_out_expiries,json=optOutExpiries,proto3" json:"opt_out_expiries"`
	// epochs_consensus_addrs is a list of epochs at the end of which the corresponding
	// consensus addresses should be pruned from the operator module.
	ConsensusAddrsToPrune []EpochToConsensusAddrs `protobuf:"bytes,4,rep,name=consensus_addrs_to_prune,json=consensusAddrsToPrune,proto3" json:"consensus_addrs_to_prune"`
	// undelegation_maturities is a list of epochs at the end of which the corresponding
	// undelegations will mature. we store its reverse lookup as well.
	UndelegationMaturities []EpochToUndelegationRecordKeys `protobuf:"bytes,5,rep,name=undelegation_maturities,json=undelegationMaturities,proto3" json:"undelegation_maturities"`
	// last_total_power tracks the total voting power as of the last validator set
	// update. such an update is most likely to be at the end of the last epoch (or the
	// beginning of this one, to be more precise) and less likely to be at other blocks,
	// since the validator set can otherwise only change as a result of slashing events.
	LastTotalPower github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,6,opt,name=last_total_power,json=lastTotalPower,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"last_total_power"`
}

func (m *GenesisState) Reset()         { *m = GenesisState{} }
func (m *GenesisState) String() string { return proto.CompactTextString(m) }
func (*GenesisState) ProtoMessage()    {}
func (*GenesisState) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a9d908a27866b1b, []int{0}
}
func (m *GenesisState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisState.Merge(m, src)
}
func (m *GenesisState) XXX_Size() int {
	return m.Size()
}
func (m *GenesisState) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisState.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

func (m *GenesisState) GetValSet() []GenesisValidator {
	if m != nil {
		return m.ValSet
	}
	return nil
}

func (m *GenesisState) GetOptOutExpiries() []EpochToOperatorAddrs {
	if m != nil {
		return m.OptOutExpiries
	}
	return nil
}

func (m *GenesisState) GetConsensusAddrsToPrune() []EpochToConsensusAddrs {
	if m != nil {
		return m.ConsensusAddrsToPrune
	}
	return nil
}

func (m *GenesisState) GetUndelegationMaturities() []EpochToUndelegationRecordKeys {
	if m != nil {
		return m.UndelegationMaturities
	}
	return nil
}

// GenesisValidator defines a genesis validator. It is a helper struct
// used for serializing the genesis state. The only reason it is a different
// structure is to support importing hex public keys from Solidity.
// TODO: consider this set up when resolving issue 73 about storage
// optimization between dogfood and operator modules.
// https://github.com/ExocoreNetwork/exocore/issues/73
type GenesisValidator struct {
	// public_key is the hex consensus public key of the validator. It should
	// be exactly 32 bytes, but this is not enforced in protobuf.
	PublicKey string `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// power is the voting power of the validator.
	Power int64 `protobuf:"varint,2,opt,name=power,proto3" json:"power,omitempty"`
	// acc_address is the operator account address of the validator.
	OperatorAccAddr string `protobuf:"bytes,3,opt,name=operator_acc_addr,json=operatorAccAddr,proto3" json:"operator_acc_addr,omitempty"`
}

func (m *GenesisValidator) Reset()         { *m = GenesisValidator{} }
func (m *GenesisValidator) String() string { return proto.CompactTextString(m) }
func (*GenesisValidator) ProtoMessage()    {}
func (*GenesisValidator) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a9d908a27866b1b, []int{1}
}
func (m *GenesisValidator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisValidator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisValidator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisValidator.Merge(m, src)
}
func (m *GenesisValidator) XXX_Size() int {
	return m.Size()
}
func (m *GenesisValidator) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisValidator.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisValidator proto.InternalMessageInfo

func (m *GenesisValidator) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *GenesisValidator) GetPower() int64 {
	if m != nil {
		return m.Power
	}
	return 0
}

func (m *GenesisValidator) GetOperatorAccAddr() string {
	if m != nil {
		return m.OperatorAccAddr
	}
	return ""
}

// EpochToOperatorAddress is used to store a mapping from epoch to a list of
// operator account addresses.
type EpochToOperatorAddrs struct {
	// epoch is the epoch in question.
	Epoch int64 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// operator_acc_addrs is the list of account addresses to expire at this epoch.
	// It is of type string for human readability of the genesis file.
	OperatorAccAddrs []string `protobuf:"bytes,2,rep,name=operator_acc_addrs,json=operatorAccAddrs,proto3" json:"operator_acc_addrs,omitempty"`
}

func (m *EpochToOperatorAddrs) Reset()         { *m = EpochToOperatorAddrs{} }
func (m *EpochToOperatorAddrs) String() string { return proto.CompactTextString(m) }
func (*EpochToOperatorAddrs) ProtoMessage()    {}
func (*EpochToOperatorAddrs) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a9d908a27866b1b, []int{2}
}
func (m *EpochToOperatorAddrs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EpochToOperatorAddrs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EpochToOperatorAddrs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EpochToOperatorAddrs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EpochToOperatorAddrs.Merge(m, src)
}
func (m *EpochToOperatorAddrs) XXX_Size() int {
	return m.Size()
}
func (m *EpochToOperatorAddrs) XXX_DiscardUnknown() {
	xxx_messageInfo_EpochToOperatorAddrs.DiscardUnknown(m)
}

var xxx_messageInfo_EpochToOperatorAddrs proto.InternalMessageInfo

func (m *EpochToOperatorAddrs) GetEpoch() int64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *EpochToOperatorAddrs) GetOperatorAccAddrs() []string {
	if m != nil {
		return m.OperatorAccAddrs
	}
	return nil
}

// EpochToConsensusAddrs is used to store a mapping from the epoch to a list of
// consensus addresses.
type EpochToConsensusAddrs struct {
	// epoch is the epoch in question.
	Epoch int64 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// cons_addrs is the list of consensus addresses to prune at this epoch.
	// It is of type string for human readability of the genesis file.
	ConsAddrs []string `protobuf:"bytes,2,rep,name=cons_addrs,json=consAddrs,proto3" json:"cons_addrs,omitempty"`
}

func (m *EpochToConsensusAddrs) Reset()         { *m = EpochToConsensusAddrs{} }
func (m *EpochToConsensusAddrs) String() string { return proto.CompactTextString(m) }
func (*EpochToConsensusAddrs) ProtoMessage()    {}
func (*EpochToConsensusAddrs) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a9d908a27866b1b, []int{3}
}
func (m *EpochToConsensusAddrs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EpochToConsensusAddrs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EpochToConsensusAddrs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EpochToConsensusAddrs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EpochToConsensusAddrs.Merge(m, src)
}
func (m *EpochToConsensusAddrs) XXX_Size() int {
	return m.Size()
}
func (m *EpochToConsensusAddrs) XXX_DiscardUnknown() {
	xxx_messageInfo_EpochToConsensusAddrs.DiscardUnknown(m)
}

var xxx_messageInfo_EpochToConsensusAddrs proto.InternalMessageInfo

func (m *EpochToConsensusAddrs) GetEpoch() int64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *EpochToConsensusAddrs) GetConsAddrs() []string {
	if m != nil {
		return m.ConsAddrs
	}
	return nil
}

// EpochToUndelegationRecordKeys is used to store a mapping from an epoch to a list of
// undelegations which mature at that epoch.
type EpochToUndelegationRecordKeys struct {
	// epoch is the epoch in question.
	Epoch int64 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// undelegation_record_keys is the list of undelegations (defined by the record key)
	// to expire at this epoch.
	// It is of type string for human readability of the genesis file.
	UndelegationRecordKeys []string `protobuf:"bytes,2,rep,name=undelegation_record_keys,json=undelegationRecordKeys,proto3" json:"undelegation_record_keys,omitempty"`
}

func (m *EpochToUndelegationRecordKeys) Reset()         { *m = EpochToUndelegationRecordKeys{} }
func (m *EpochToUndelegationRecordKeys) String() string { return proto.CompactTextString(m) }
func (*EpochToUndelegationRecordKeys) ProtoMessage()    {}
func (*EpochToUndelegationRecordKeys) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a9d908a27866b1b, []int{4}
}
func (m *EpochToUndelegationRecordKeys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EpochToUndelegationRecordKeys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EpochToUndelegationRecordKeys.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EpochToUndelegationRecordKeys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EpochToUndelegationRecordKeys.Merge(m, src)
}
func (m *EpochToUndelegationRecordKeys) XXX_Size() int {
	return m.Size()
}
func (m *EpochToUndelegationRecordKeys) XXX_DiscardUnknown() {
	xxx_messageInfo_EpochToUndelegationRecordKeys.DiscardUnknown(m)
}

var xxx_messageInfo_EpochToUndelegationRecordKeys proto.InternalMessageInfo

func (m *EpochToUndelegationRecordKeys) GetEpoch() int64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *EpochToUndelegationRecordKeys) GetUndelegationRecordKeys() []string {
	if m != nil {
		return m.UndelegationRecordKeys
	}
	return nil
}

func init() {
	proto.RegisterType((*GenesisState)(nil), "exocore.dogfood.v1.GenesisState")
	proto.RegisterType((*GenesisValidator)(nil), "exocore.dogfood.v1.GenesisValidator")
	proto.RegisterType((*EpochToOperatorAddrs)(nil), "exocore.dogfood.v1.EpochToOperatorAddrs")
	proto.RegisterType((*EpochToConsensusAddrs)(nil), "exocore.dogfood.v1.EpochToConsensusAddrs")
	proto.RegisterType((*EpochToUndelegationRecordKeys)(nil), "exocore.dogfood.v1.EpochToUndelegationRecordKeys")
}

func init() { proto.RegisterFile("exocore/dogfood/v1/genesis.proto", fileDescriptor_1a9d908a27866b1b) }

var fileDescriptor_1a9d908a27866b1b = []byte{
	// 593 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x94, 0xc1, 0x4e, 0xdb, 0x30,
	0x18, 0xc7, 0x1b, 0x0a, 0x4c, 0x35, 0x88, 0x15, 0x0b, 0xb6, 0x08, 0x89, 0x50, 0x55, 0xd3, 0xd4,
	0xa1, 0x2d, 0x51, 0xe1, 0xc2, 0x15, 0x10, 0x9a, 0x26, 0xb6, 0x81, 0x02, 0x9b, 0x26, 0xa4, 0x29,
	0x32, 0x8e, 0x17, 0x22, 0xd2, 0x7c, 0x96, 0xed, 0x94, 0xf6, 0x2d, 0xf6, 0x0c, 0x3b, 0xed, 0xb8,
	0xc7, 0xe0, 0xc8, 0x71, 0xda, 0x01, 0x4d, 0xed, 0x61, 0xaf, 0x31, 0xd9, 0x49, 0x50, 0x0b, 0xa5,
	0x97, 0xd6, 0xfe, 0xfa, 0xff, 0x7e, 0x7f, 0xd7, 0xff, 0x4f, 0x46, 0x0d, 0xd6, 0x03, 0x0a, 0x82,
	0x79, 0x21, 0x44, 0xdf, 0x00, 0x42, 0xaf, 0xdb, 0xf6, 0x22, 0x96, 0x32, 0x19, 0x4b, 0x97, 0x0b,
	0x50, 0x80, 0x71, 0xa1, 0x70, 0x0b, 0x85, 0xdb, 0x6d, 0xaf, 0x2d, 0x93, 0x4e, 0x9c, 0x82, 0x67,
	0x3e, 0x73, 0xd9, 0xda, 0x4a, 0x04, 0x11, 0x98, 0xa5, 0xa7, 0x57, 0x45, 0x75, 0x63, 0x02, 0x9e,
	0x13, 0x41, 0x3a, 0x05, 0xbd, 0xf9, 0x63, 0x16, 0x2d, 0xbe, 0xcd, 0xfd, 0x4e, 0x14, 0x51, 0x0c,
	0xef, 0xa0, 0xf9, 0x5c, 0x60, 0x5b, 0x0d, 0xab, 0xb5, 0xb0, 0xb5, 0xe6, 0x3e, 0xf4, 0x77, 0x8f,
	0x8d, 0x62, 0x6f, 0xf6, 0xfa, 0x76, 0xa3, 0xe2, 0x17, 0x7a, 0xbc, 0x8f, 0x9e, 0x74, 0x49, 0x12,
	0x48, 0xa6, 0xec, 0x99, 0x46, 0xb5, 0xb5, 0xb0, 0xf5, 0x62, 0x52, 0x6b, 0x61, 0xf6, 0x99, 0x24,
	0x71, 0x48, 0x14, 0x88, 0x12, 0xd2, 0x25, 0xc9, 0x09, 0x53, 0xf8, 0x0b, 0xaa, 0x03, 0x57, 0x01,
	0x64, 0x2a, 0x60, 0x3d, 0x1e, 0x8b, 0x98, 0x49, 0xbb, 0x6a, 0x68, 0xad, 0x49, 0xb4, 0x03, 0x0e,
	0xf4, 0xe2, 0x14, 0x8e, 0x38, 0x13, 0x1a, 0xb6, 0x1b, 0x86, 0xa2, 0x3c, 0xd6, 0x12, 0x70, 0x75,
	0x94, 0xa9, 0x83, 0x82, 0x82, 0x2f, 0x90, 0x4d, 0x21, 0x95, 0x2c, 0x95, 0x99, 0x0c, 0x88, 0x16,
	0x06, 0x0a, 0x02, 0x2e, 0xb2, 0x94, 0xd9, 0xb3, 0xc6, 0xe1, 0xd5, 0x14, 0x87, 0xfd, 0xb2, 0x75,
	0xd4, 0x62, 0x95, 0x8e, 0x55, 0x4f, 0xe1, 0x58, 0xd3, 0x30, 0x47, 0xcf, 0xb3, 0x34, 0x64, 0x09,
	0x8b, 0x88, 0x8a, 0x21, 0x0d, 0x3a, 0x44, 0x65, 0x22, 0x56, 0xfa, 0xaf, 0xcc, 0x19, 0xa3, 0xf6,
	0x14, 0xa3, 0x4f, 0x23, 0x9d, 0x3e, 0xa3, 0x20, 0xc2, 0x43, 0xd6, 0x2f, 0x0d, 0x9f, 0x8d, 0x72,
	0x3f, 0xdc, 0x61, 0xf1, 0x57, 0x54, 0x4f, 0x88, 0x54, 0x81, 0x02, 0x45, 0x92, 0x80, 0xc3, 0x15,
	0x13, 0xf6, 0x7c, 0xc3, 0x6a, 0x2d, 0xee, 0x6d, 0xeb, 0xbe, 0x3f, 0xb7, 0x1b, 0x2f, 0xa3, 0x58,
	0x5d, 0x64, 0xe7, 0x2e, 0x85, 0x8e, 0x47, 0x41, 0x76, 0x40, 0x16, 0x5f, 0x6f, 0x64, 0x78, 0xe9,
	0xa9, 0x3e, 0x67, 0xd2, 0x7d, 0x97, 0xaa, 0x9f, 0xff, 0x7e, 0x6d, 0x5a, 0xfe, 0x92, 0x86, 0x9d,
	0x6a, 0xd6, 0xb1, 0x46, 0x35, 0x25, 0xaa, 0xdf, 0x8f, 0x0d, 0xaf, 0x23, 0xc4, 0xb3, 0xf3, 0x24,
	0xa6, 0xc1, 0x25, 0xeb, 0x9b, 0x59, 0xa9, 0xf9, 0xb5, 0xbc, 0x72, 0xc8, 0xfa, 0x78, 0x05, 0xcd,
	0xe5, 0xc7, 0x98, 0x69, 0x58, 0xad, 0xaa, 0x9f, 0x6f, 0xf0, 0x26, 0x5a, 0x86, 0x22, 0xaa, 0x80,
	0x50, 0x6a, 0x62, 0xb0, 0xab, 0xa6, 0xf7, 0x69, 0xf9, 0xc3, 0x2e, 0xa5, 0xfa, 0x36, 0x9b, 0x67,
	0x68, 0x65, 0x52, 0xba, 0x9a, 0xcc, 0x74, 0xdd, 0x78, 0x56, 0xfd, 0x7c, 0x83, 0x5f, 0x23, 0xfc,
	0x80, 0x2c, 0xcd, 0x1c, 0xd6, 0xfc, 0xfa, 0x3d, 0xb4, 0x6c, 0xbe, 0x47, 0xab, 0x13, 0x73, 0x7d,
	0x04, 0xbe, 0x8e, 0x90, 0x4e, 0x7a, 0x0c, 0x5a, 0xd3, 0x95, 0x9c, 0x06, 0x68, 0x7d, 0x6a, 0x78,
	0x8f, 0x50, 0x77, 0x90, 0x3d, 0x36, 0x26, 0xc2, 0x34, 0xe8, 0xeb, 0x2c, 0x3d, 0xc6, 0xe2, 0x1e,
	0x19, 0x86, 0xc3, 0xeb, 0x81, 0x63, 0xdd, 0x0c, 0x1c, 0xeb, 0xef, 0xc0, 0xb1, 0xbe, 0x0f, 0x9d,
	0xca, 0xcd, 0xd0, 0xa9, 0xfc, 0x1e, 0x3a, 0x95, 0xb3, 0xf6, 0x48, 0xcc, 0x07, 0xf9, 0x8c, 0x7d,
	0x64, 0xea, 0x0a, 0xc4, 0xa5, 0x57, 0xbe, 0x04, 0xbd, 0xbb, 0xb7, 0xc0, 0xa4, 0x7e, 0x3e, 0x6f,
	0x1e, 0x82, 0xed, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x4c, 0x49, 0x3b, 0x8a, 0x04, 0x00,
	0x00,
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.LastTotalPower.Size()
		i -= size
		if _, err := m.LastTotalPower.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.UndelegationMaturities) > 0 {
		for iNdEx := len(m.UndelegationMaturities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UndelegationMaturities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ConsensusAddrsToPrune) > 0 {
		for iNdEx := len(m.ConsensusAddrsToPrune) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConsensusAddrsToPrune[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.OptOutExpiries) > 0 {
		for iNdEx := len(m.OptOutExpiries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OptOutExpiries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ValSet) > 0 {
		for iNdEx := len(m.ValSet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValSet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GenesisValidator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisValidator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OperatorAccAddr) > 0 {
		i -= len(m.OperatorAccAddr)
		copy(dAtA[i:], m.OperatorAccAddr)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.OperatorAccAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Power != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.Power))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EpochToOperatorAddrs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpochToOperatorAddrs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EpochToOperatorAddrs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OperatorAccAddrs) > 0 {
		for iNdEx := len(m.OperatorAccAddrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OperatorAccAddrs[iNdEx])
			copy(dAtA[i:], m.OperatorAccAddrs[iNdEx])
			i = encodeVarintGenesis(dAtA, i, uint64(len(m.OperatorAccAddrs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Epoch != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EpochToConsensusAddrs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpochToConsensusAddrs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EpochToConsensusAddrs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConsAddrs) > 0 {
		for iNdEx := len(m.ConsAddrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ConsAddrs[iNdEx])
			copy(dAtA[i:], m.ConsAddrs[iNdEx])
			i = encodeVarintGenesis(dAtA, i, uint64(len(m.ConsAddrs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Epoch != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EpochToUndelegationRecordKeys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpochToUndelegationRecordKeys) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EpochToUndelegationRecordKeys) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UndelegationRecordKeys) > 0 {
		for iNdEx := len(m.UndelegationRecordKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UndelegationRecordKeys[iNdEx])
			copy(dAtA[i:], m.UndelegationRecordKeys[iNdEx])
			i = encodeVarintGenesis(dAtA, i, uint64(len(m.UndelegationRecordKeys[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Epoch != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintGenesis(dAtA []byte, offset int, v uint64) int {
	offset -= sovGenesis(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GenesisState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovGenesis(uint64(l))
	if len(m.ValSet) > 0 {
		for _, e := range m.ValSet {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.OptOutExpiries) > 0 {
		for _, e := range m.OptOutExpiries {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.ConsensusAddrsToPrune) > 0 {
		for _, e := range m.ConsensusAddrsToPrune {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.UndelegationMaturities) > 0 {
		for _, e := range m.UndelegationMaturities {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	l = m.LastTotalPower.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *GenesisValidator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	if m.Power != 0 {
		n += 1 + sovGenesis(uint64(m.Power))
	}
	l = len(m.OperatorAccAddr)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	return n
}

func (m *EpochToOperatorAddrs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovGenesis(uint64(m.Epoch))
	}
	if len(m.OperatorAccAddrs) > 0 {
		for _, s := range m.OperatorAccAddrs {
			l = len(s)
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	return n
}

func (m *EpochToConsensusAddrs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovGenesis(uint64(m.Epoch))
	}
	if len(m.ConsAddrs) > 0 {
		for _, s := range m.ConsAddrs {
			l = len(s)
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	return n
}

func (m *EpochToUndelegationRecordKeys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovGenesis(uint64(m.Epoch))
	}
	if len(m.UndelegationRecordKeys) > 0 {
		for _, s := range m.UndelegationRecordKeys {
			l = len(s)
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	return n
}

func sovGenesis(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGenesis(x uint64) (n int) {
	return sovGenesis(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GenesisState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValSet = append(m.ValSet, GenesisValidator{})
			if err := m.ValSet[len(m.ValSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptOutExpiries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptOutExpiries = append(m.OptOutExpiries, EpochToOperatorAddrs{})
			if err := m.OptOutExpiries[len(m.OptOutExpiries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusAddrsToPrune", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsensusAddrsToPrune = append(m.ConsensusAddrsToPrune, EpochToConsensusAddrs{})
			if err := m.ConsensusAddrsToPrune[len(m.ConsensusAddrsToPrune)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndelegationMaturities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UndelegationMaturities = append(m.UndelegationMaturities, EpochToUndelegationRecordKeys{})
			if err := m.UndelegationMaturities[len(m.UndelegationMaturities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTotalPower", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastTotalPower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisValidator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisValidator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisValidator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorAccAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorAccAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpochToOperatorAddrs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochToOperatorAddrs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochToOperatorAddrs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorAccAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorAccAddrs = append(m.OperatorAccAddrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpochToConsensusAddrs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochToConsensusAddrs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochToConsensusAddrs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsAddrs = append(m.ConsAddrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpochToUndelegationRecordKeys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochToUndelegationRecordKeys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochToUndelegationRecordKeys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndelegationRecordKeys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UndelegationRecordKeys = append(m.UndelegationRecordKeys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGenesis(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGenesis
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGenesis
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGenesis
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGenesis        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGenesis          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGenesis = fmt.Errorf("proto: unexpected end of group")
)
