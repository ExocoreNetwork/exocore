syntax = "proto3";
package exocore.oracle;

import "gogoproto/gogo.proto";
import "exocore/oracle/info.proto";

option go_package = "github.com/ExocoreNetwork/exocore/x/oracle/types";

//n out of m required source
message NOMSource{
	//required source set, refer to params.sourceList, 1st set to 0 means all valid sources
	repeated int32 source_ids = 1;
	//minimum number from the required sources to be fullfiled
	int32 minimum = 2;
}

//specify data from which source is needed
//rule_1: specified sources
//rule_2: n out of total sources are required
message RuleWithSource{
  //refer to params.sourceList.ID, when length>0, ignore the other field, when 1st set to 0, means all valid sources, length==0->check next field:minimum
  repeated int32 source_ids = 1;  
  //n out of total sources are required
  NOMSource nom = 2;
}

//Tokenfeeder represents a price oracle for one token
message TokenFeeder{
  //refer to params.tokenList, from 1
  int32 token_id = 1;
  //refer to params.ruleList, 0 means no restriction, accept any source including customer defined
  int32 rule_id = 2;
  //include, from 1, when some token's feeder had been stop and then restart, the token_id will be continuous from previous one
  int64 start_round_id = 3;
  //include, first block which start_round_id can be settled is at least start_base_block+1
  int64 start_base_block = 4;
  //set as count of blocks, for how many blocks interval the price will be update once
  int64 interval = 5;
  //tokenfeeder is initialized with forever live, update the End parameters by voting, and will off service by the end
  //this is set by updateParams, and the EndRoundID will be update by related. excluded, will not work if current height >=EndBlock
  int64 end_block = 6;
}
